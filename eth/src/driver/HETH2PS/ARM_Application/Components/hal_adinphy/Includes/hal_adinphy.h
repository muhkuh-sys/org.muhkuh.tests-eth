/**
 * \file
 * \brief Prototypes and defines for external PHY ADIN1100 as used on NXEB 90-SPE board
 *
 * \author Marvin Mager - mmager@hilscher.com
 * \copyright Hilscher Gesellschaft fuer Systemautomation mbH. All Rights Reserved.
 *
 * \mainpage Introduction
 * This HAL implements low level functions to interface with an ADIN1100 10BASE-T1L PHY and is
 * intended for netX 90 targets only. It furthermore implements MDIO clause 45 using bit-banging
 * and the MIIMU-SW registers of the netX 90's xC channel 1.
 *
 * Up to two external PHYs can be initialized with their own hardware ID using `adinphy_initialize()`.
 * Hardware interrupts from all PHYs are connected in parallel to `HIF_DIRQ` and are handled in
 * `adinphy_irq_handler()`. During this routine, the link status of all initialized PHYs is checked
 * and, if a link change occurred, the callback registered with `adinphy_register_link_state_callback()`
 * is called.
 *
 * The following helper functions are provided to interface with existing HALs:
 *  - `adinphy_read_cl45()`: Read from MDIO with clause 45 frame format
 *  - `adinphy_read_cl45()`: Write to MDIO with clause 45 frame format
 *  - `adinphy_get_linkstate()`: Retrieve link state, duplex mode and speed information from a PHY
 *
 * The HAL supports both chip versions of the PHY, version U1 and U2. To select a version, set
 * `ADIN1100_CHIP_REV` to the desired version and include the respective register definition header
 * file. Official support and tests are only applicable for chip version U2, as version U1 was a
 * pre-release candidate of the PHY.
 *
 * **Changelog**
 *
 * | Version     | Name | Date       | Changes                                                    |
 * |-------------|------|------------|------------------------------------------------------------|
 * | `v1.0.0.0`  | MMA  | 08.09.2021 | Initial release                                            |
 */

#ifndef HAL_ADINPHY_H_
#define HAL_ADINPHY_H_

#include <stdint.h>
#include <stdbool.h>

/* Return codes */
#define RC_OKAY 0             /*!< Function exits normally */
#define RC_INVALID_PARAM 1    /*!< A given parameter was invalid */
#define RC_CONFIG_ERR 2       /*!< Some configuration was wrong */

/*!
 * Data structure with information about an external SPE PHY
 */
typedef struct spe_phy_s {
  uint8_t mdio_addr;          /*!< MDIO hardware address of the external PHY, must not change after initialization */
  uint8_t port;               /*!< Number of the xC port the PHY is connected to, must not change after initialization */
  bool initialized;           /*!< Flag is set when `adinphy_initialize()` was called for this PHY */
  void* pt_instance;          /*!< Pointer on a port instance (example of type `ETH_T`) that is related to this PHY */
} SPE_PHY_T;

/*!
 * Initialize the external PHY on given xC port
 *
 * To initialize the PHY, a hardware reset (via `RST_OUT_N`) as well as a software reset are performed.
 * After initialization, the PHY stays in software power-down mode. The LED0 (or LED on rev U1 chips)
 * of the PHY will be set to blink upon TX/RX activity with a period of 50ms. Furthermore, all pending
 * interrupts will be cleared.
 *
 * \param [in] xc_port    xC channel on which the external PHY is connected to
 * \param [in] mdio_addr  Hardware address of the external PHY for MDIO access
 * \param [in] pt_inst    User definable pointer (e.g. to an instance) hat can be accessed
 *                        in the link state change callback
 * \return
 *  - **RC_OKAY**              : Initialization successful
 *  - **RC_INVALID_PARAMETER** : Wrong parameter submitted
 */
int adinphy_initialize(uint8_t xc_port, uint8_t mdio_addr, void* pt_inst);


/*!
 * Release external PHY from software power-down
 *
 * The PHY will be released from its software power-down state and auto-negotiation will be restarted.
 *
 * \param [in] xc_port    xC channel on which the external PHY is connected to
 *
 * \return
 *  - RC_OKAY              : Initialization successful
 *  - RC_INVALID_PARAMETER : Wrong parameter submitted
 */
int adinphy_release(uint8_t xc_port);

/*!
 * Setup interrupts for HIF_DIRQ (MMIO17)
 *
 * Used to capture INT_N generated by the external PHYs. This function will not register an interrupt
 * handler on the ARM, it only sets the respective registers to use HIF_DIRQ and capture an interrupt
 * on low signal level at this pin.
 */
void adinphy_setup_irq();

/*!
 * Interrupt service routine for HIF_DIRQ (MMIO17) pin
 *
 * This pin is pulled low when the ADIN1100 PHY generates an interrupt. The function does not reset
 * the ARM NVIC IRQ vector, but does clear the interrupt in hif_pio_irq_raw.
 *
 * When an interrupt is asserted, all initialized PHYs are polled via MDIO. When a reset was detected
 * during runtime, the corresponding PHY is reinitialized. When a link status change was detected,
 * the link state callback (registered with `adinphy_register_link_state_callback()`) is called with
 * a pointer on the corresponding SPE PHY's data structure as parameter.
 */
void adinphy_irq_handler();

/*!
 * Reference a callback for link state changes
 *
 * The callback will be called upon a link state change of any SPE PHY with a pointer to the PHY's data
 * structure of type SPE_PHY_T as first parameter. To pass additional parameters to the callback function,
 * use the pt_instance pointer that is available in this data structure. This pointer can be assigned
 * after initialization with adinphy_initialize(). The callback shall have the following definition:
 *  - `void my_callback(void* ptContext) { }`
 *
 * \param[in] link_state_callback  Pointer to a callback function
 */
void adinphy_register_link_state_callback(void(*link_state_callback)(void* pvCtx));

/*!
 * Retrieve link state of external ADIN PHY.
 *
 * Retrieves lin status, speed status and duplex information for the external PHY on given xC port. The
 * function is build to fit into the existing PHY HAL, but always returns 10MBit/s speed and full-duplex
 * as this PHY does not support other modes.
 *
 * \param [in]  xc_port   xC channel on which the external PHY is connected to
 * \param [out] link      Current link state (1 = link up, 0 = no link)
 * \param [out] speed     Current link speed (always 10 MBit/s)
 * \param [out] duplex    Current duplex mode (always 1 for full-duplex)

 * \return
 *  - **RC_OKAY**              : Initialization successful
 *  - **RC_CONFIG_ERR**        : External PHY on this port is uninitialized
 *  - **RC_INVALID_PARAMETER** : Wrong parameter submitted
 */
int adinphy_get_linkstate(uint8_t xc_port, unsigned int* link, unsigned int* speed, unsigned int* duplex);

/*!
 * Read from a register of the external PHY using MDIO clause 45
 *
 * Sends both the address frame as well as the read frame to the MDIO bus to read from a specific
 * register of the external PHY with given hardware address. During MDIO access, the HIF_PIO
 * interrupts are disabled but all other interrupts are still active.
 *
 * reg_addr_combined expects a combined hexadecimal address of both the targeted register as well
 * as MMD. For example, register 0x0201 of MMD 0x1E has to be concatenated to 0x1E0201. Format:
 *  - `reg_addr_combined = 0x (MMD) (REGAD)`
 *
 * \param [in]  phy_addr            Hardware address of the targeted PHY
 * \param [in]  reg_addr_combined   Combined register address
 * \param [out] data                Data read from PHY
 *
 * \return
 *  - **RC_OKAY**              : Register was read
 *  - **RC_INVALID_PARAMETER** : Wrong parameter submitted
 */
int adinphy_read_reg(uint8_t phy_addr, uint32_t reg_addr_combined, uint16_t* data);

/*!
 * Write to a register of the external PHY via MDIO clause 45
 *
 * Sends both the address frame as well as the write frame to the MDIO bus to write data to
 * a specific register of the external PHY with given hardware address. During MDIO access,
 * the HIF_PIO interrupts are disabled but all other interrupts are still active.
 *
 * reg_addr_combined expects a combined hexadecimal address of both the targeted register as well
 * as MMD. For example, register 0x0201 of MMD 0x1E has to be concatenated to 0x1E0201. Format:
 *  - `reg_addr_combined = 0x (MMD) (REGAD)`
 *
 * \param [in]  phy_addr            Hardware address of the targeted PHY
 * \param [in]  reg_addr_combined   Combined register address
 * \param [out] data                Data to write to the PHY
 *
 * \return
 *  - **RC_OKAY**              : Register was written
 *  - **RC_INVALID_PARAMETER** : Wrong parameter submitted
 */
int adinphy_write_reg(uint8_t phy_addr, uint32_t reg_addr_combined, uint16_t data);

/*!
 * Helper function to read from external PHY with MDIO clause 45
 *
 * Read from MDIO with clause 45 frame format. Register addresses need to be in their combined
 * format. Registers 0x2 and 0x3 are appended their correct MMD address to add support for existing PHY
 * HAL to retrieve the PHY ID. All other clause 22 registers return 0.
 *
 * \param [in] uiPhy    Hardware address (MDIO address) of PHY
 * \param [in] uiReg    Register address in combined format (e.g. 0x1E0020)
 *
 * \return Data read from PHY in given register
 * \see `adinphy_read_reg()` for description of combined addresses
 */
unsigned int adinphy_read_cl45(unsigned int uiPhy, unsigned int uiReg);

/*!
 * Helper function to write to external PHY with MDIO clause 45
 *
 * Write to MDIO with clause 45 frame format. Register addresses need to be in their combined
 * format. All clause 22 addresses are ignored.
 *
 * \param [in] uiPhy    Hardware address (MDIO address) of PHY
 * \param [in] uiReg    Register address in combined format (e.g. 0x1E0020)
 * \param [in] uiValue  Value to write to the given register
 *
 * \see `adinphy_write_reg()` for description of combined addresses
 */
void adinphy_write_cl45(unsigned int uiPhy, unsigned int uiReg, unsigned int uiValue);

#endif /* HAL_ADINPHY_H_ */
